// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server/event/event.proto

/*
	Package event is a generated protocol buffer package.

	It is generated from these files:
		server/event/event.proto

	It has these top-level messages:
		Event
		FailNetwork
		FailProtocol
		ServerAccess
		FailRequest
		ProgramLoad
		ProgramCreate
		ProgramCheck
		InstanceCreate
		InstanceAttach
		InstanceDetach
		InstanceDelete
*/
package event

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import detail "github.com/tsavola/gate/server/detail"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Event_Type int32

const (
	Event_FailNetwork    Event_Type = 0
	Event_FailProtocol   Event_Type = 1
	Event_ServerAccess   Event_Type = 2
	Event_FailRequest    Event_Type = 3
	Event_ProgramLoad    Event_Type = 4
	Event_ProgramCreate  Event_Type = 5
	Event_ProgramCheck   Event_Type = 6
	Event_InstanceCreate Event_Type = 7
	Event_InstanceAttach Event_Type = 8
	Event_InstanceDetach Event_Type = 9
	Event_InstanceDelete Event_Type = 10
)

var Event_Type_name = map[int32]string{
	0:  "FailNetwork",
	1:  "FailProtocol",
	2:  "ServerAccess",
	3:  "FailRequest",
	4:  "ProgramLoad",
	5:  "ProgramCreate",
	6:  "ProgramCheck",
	7:  "InstanceCreate",
	8:  "InstanceAttach",
	9:  "InstanceDetach",
	10: "InstanceDelete",
}
var Event_Type_value = map[string]int32{
	"FailNetwork":    0,
	"FailProtocol":   1,
	"ServerAccess":   2,
	"FailRequest":    3,
	"ProgramLoad":    4,
	"ProgramCreate":  5,
	"ProgramCheck":   6,
	"InstanceCreate": 7,
	"InstanceAttach": 8,
	"InstanceDetach": 9,
	"InstanceDelete": 10,
}

func (x Event_Type) String() string {
	return proto.EnumName(Event_Type_name, int32(x))
}
func (Event_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorEvent, []int{0, 0} }

type FailRequest_Type int32

const (
	FailRequest_PAYLOAD_ERROR         FailRequest_Type = 0
	FailRequest_PROGRAM_NOT_FOUND     FailRequest_Type = 1
	FailRequest_PROGRAM_HASH_MISMATCH FailRequest_Type = 2
	FailRequest_INSTANCE_NOT_FOUND    FailRequest_Type = 3
	FailRequest_IO_CONFLICT           FailRequest_Type = 4
)

var FailRequest_Type_name = map[int32]string{
	0: "PAYLOAD_ERROR",
	1: "PROGRAM_NOT_FOUND",
	2: "PROGRAM_HASH_MISMATCH",
	3: "INSTANCE_NOT_FOUND",
	4: "IO_CONFLICT",
}
var FailRequest_Type_value = map[string]int32{
	"PAYLOAD_ERROR":         0,
	"PROGRAM_NOT_FOUND":     1,
	"PROGRAM_HASH_MISMATCH": 2,
	"INSTANCE_NOT_FOUND":    3,
	"IO_CONFLICT":           4,
}

func (x FailRequest_Type) String() string {
	return proto.EnumName(FailRequest_Type_name, int32(x))
}
func (FailRequest_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorEvent, []int{4, 0} }

type Event struct {
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptorEvent, []int{0} }

type FailNetwork struct {
	Context detail.Context `protobuf:"bytes,1,opt,name=context" json:"context"`
}

func (m *FailNetwork) Reset()                    { *m = FailNetwork{} }
func (m *FailNetwork) String() string            { return proto.CompactTextString(m) }
func (*FailNetwork) ProtoMessage()               {}
func (*FailNetwork) Descriptor() ([]byte, []int) { return fileDescriptorEvent, []int{1} }

type FailProtocol struct {
	Context detail.Context `protobuf:"bytes,1,opt,name=context" json:"context"`
}

func (m *FailProtocol) Reset()                    { *m = FailProtocol{} }
func (m *FailProtocol) String() string            { return proto.CompactTextString(m) }
func (*FailProtocol) ProtoMessage()               {}
func (*FailProtocol) Descriptor() ([]byte, []int) { return fileDescriptorEvent, []int{2} }

type ServerAccess struct {
	Context  detail.Context `protobuf:"bytes,1,opt,name=context" json:"context"`
	Protocol string         `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Method   string         `protobuf:"bytes,3,opt,name=method,proto3" json:"method,omitempty"`
	Url      string         `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *ServerAccess) Reset()                    { *m = ServerAccess{} }
func (m *ServerAccess) String() string            { return proto.CompactTextString(m) }
func (*ServerAccess) ProtoMessage()               {}
func (*ServerAccess) Descriptor() ([]byte, []int) { return fileDescriptorEvent, []int{3} }

type FailRequest struct {
	Context     detail.Context   `protobuf:"bytes,1,opt,name=context" json:"context"`
	Type        FailRequest_Type `protobuf:"varint,2,opt,name=type,proto3,enum=event.FailRequest_Type" json:"type,omitempty"`
	ProgramId   string           `protobuf:"bytes,3,opt,name=program_id,json=programId,proto3" json:"program_id,omitempty"`
	InstanceArg int32            `protobuf:"varint,4,opt,name=instance_arg,json=instanceArg,proto3" json:"instance_arg,omitempty"`
	InstanceId  string           `protobuf:"bytes,5,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
}

func (m *FailRequest) Reset()                    { *m = FailRequest{} }
func (m *FailRequest) String() string            { return proto.CompactTextString(m) }
func (*FailRequest) ProtoMessage()               {}
func (*FailRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvent, []int{4} }

type ProgramLoad struct {
	Context     detail.Context `protobuf:"bytes,1,opt,name=context" json:"context"`
	ProgramHash string         `protobuf:"bytes,2,opt,name=program_hash,json=programHash,proto3" json:"program_hash,omitempty"`
}

func (m *ProgramLoad) Reset()                    { *m = ProgramLoad{} }
func (m *ProgramLoad) String() string            { return proto.CompactTextString(m) }
func (*ProgramLoad) ProtoMessage()               {}
func (*ProgramLoad) Descriptor() ([]byte, []int) { return fileDescriptorEvent, []int{5} }

type ProgramCreate struct {
	Context     detail.Context `protobuf:"bytes,1,opt,name=context" json:"context"`
	ProgramHash string         `protobuf:"bytes,2,opt,name=program_hash,json=programHash,proto3" json:"program_hash,omitempty"`
	ProgramId   string         `protobuf:"bytes,3,opt,name=program_id,json=programId,proto3" json:"program_id,omitempty"`
}

func (m *ProgramCreate) Reset()                    { *m = ProgramCreate{} }
func (m *ProgramCreate) String() string            { return proto.CompactTextString(m) }
func (*ProgramCreate) ProtoMessage()               {}
func (*ProgramCreate) Descriptor() ([]byte, []int) { return fileDescriptorEvent, []int{6} }

type ProgramCheck struct {
	Context   detail.Context `protobuf:"bytes,1,opt,name=context" json:"context"`
	ProgramId string         `protobuf:"bytes,2,opt,name=program_id,json=programId,proto3" json:"program_id,omitempty"`
}

func (m *ProgramCheck) Reset()                    { *m = ProgramCheck{} }
func (m *ProgramCheck) String() string            { return proto.CompactTextString(m) }
func (*ProgramCheck) ProtoMessage()               {}
func (*ProgramCheck) Descriptor() ([]byte, []int) { return fileDescriptorEvent, []int{7} }

type InstanceCreate struct {
	Context    detail.Context `protobuf:"bytes,1,opt,name=context" json:"context"`
	ProgramId  string         `protobuf:"bytes,2,opt,name=program_id,json=programId,proto3" json:"program_id,omitempty"`
	InstanceId string         `protobuf:"bytes,3,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
}

func (m *InstanceCreate) Reset()                    { *m = InstanceCreate{} }
func (m *InstanceCreate) String() string            { return proto.CompactTextString(m) }
func (*InstanceCreate) ProtoMessage()               {}
func (*InstanceCreate) Descriptor() ([]byte, []int) { return fileDescriptorEvent, []int{8} }

type InstanceAttach struct {
	Context    detail.Context `protobuf:"bytes,1,opt,name=context" json:"context"`
	InstanceId string         `protobuf:"bytes,2,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
}

func (m *InstanceAttach) Reset()                    { *m = InstanceAttach{} }
func (m *InstanceAttach) String() string            { return proto.CompactTextString(m) }
func (*InstanceAttach) ProtoMessage()               {}
func (*InstanceAttach) Descriptor() ([]byte, []int) { return fileDescriptorEvent, []int{9} }

type InstanceDetach struct {
	Context    detail.Context `protobuf:"bytes,1,opt,name=context" json:"context"`
	InstanceId string         `protobuf:"bytes,2,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
}

func (m *InstanceDetach) Reset()                    { *m = InstanceDetach{} }
func (m *InstanceDetach) String() string            { return proto.CompactTextString(m) }
func (*InstanceDetach) ProtoMessage()               {}
func (*InstanceDetach) Descriptor() ([]byte, []int) { return fileDescriptorEvent, []int{10} }

type InstanceDelete struct {
	Context    detail.Context `protobuf:"bytes,1,opt,name=context" json:"context"`
	InstanceId string         `protobuf:"bytes,2,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
}

func (m *InstanceDelete) Reset()                    { *m = InstanceDelete{} }
func (m *InstanceDelete) String() string            { return proto.CompactTextString(m) }
func (*InstanceDelete) ProtoMessage()               {}
func (*InstanceDelete) Descriptor() ([]byte, []int) { return fileDescriptorEvent, []int{11} }

func init() {
	proto.RegisterType((*Event)(nil), "event.Event")
	proto.RegisterType((*FailNetwork)(nil), "event.FailNetwork")
	proto.RegisterType((*FailProtocol)(nil), "event.FailProtocol")
	proto.RegisterType((*ServerAccess)(nil), "event.ServerAccess")
	proto.RegisterType((*FailRequest)(nil), "event.FailRequest")
	proto.RegisterType((*ProgramLoad)(nil), "event.ProgramLoad")
	proto.RegisterType((*ProgramCreate)(nil), "event.ProgramCreate")
	proto.RegisterType((*ProgramCheck)(nil), "event.ProgramCheck")
	proto.RegisterType((*InstanceCreate)(nil), "event.InstanceCreate")
	proto.RegisterType((*InstanceAttach)(nil), "event.InstanceAttach")
	proto.RegisterType((*InstanceDetach)(nil), "event.InstanceDetach")
	proto.RegisterType((*InstanceDelete)(nil), "event.InstanceDelete")
	proto.RegisterEnum("event.Event_Type", Event_Type_name, Event_Type_value)
	proto.RegisterEnum("event.FailRequest_Type", FailRequest_Type_name, FailRequest_Type_value)
}
func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FailNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailNetwork) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Context.Size()))
	n1, err := m.Context.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	return i, nil
}

func (m *FailProtocol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailProtocol) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Context.Size()))
	n2, err := m.Context.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *ServerAccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerAccess) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Context.Size()))
	n3, err := m.Context.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.Method) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *FailRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Context.Size()))
	n4, err := m.Context.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEvent(dAtA, i, uint64(m.Type))
	}
	if len(m.ProgramId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ProgramId)))
		i += copy(dAtA[i:], m.ProgramId)
	}
	if m.InstanceArg != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEvent(dAtA, i, uint64(m.InstanceArg))
	}
	if len(m.InstanceId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.InstanceId)))
		i += copy(dAtA[i:], m.InstanceId)
	}
	return i, nil
}

func (m *ProgramLoad) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProgramLoad) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Context.Size()))
	n5, err := m.Context.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.ProgramHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ProgramHash)))
		i += copy(dAtA[i:], m.ProgramHash)
	}
	return i, nil
}

func (m *ProgramCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProgramCreate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Context.Size()))
	n6, err := m.Context.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.ProgramHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ProgramHash)))
		i += copy(dAtA[i:], m.ProgramHash)
	}
	if len(m.ProgramId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ProgramId)))
		i += copy(dAtA[i:], m.ProgramId)
	}
	return i, nil
}

func (m *ProgramCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProgramCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Context.Size()))
	n7, err := m.Context.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if len(m.ProgramId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ProgramId)))
		i += copy(dAtA[i:], m.ProgramId)
	}
	return i, nil
}

func (m *InstanceCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceCreate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Context.Size()))
	n8, err := m.Context.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.ProgramId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ProgramId)))
		i += copy(dAtA[i:], m.ProgramId)
	}
	if len(m.InstanceId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.InstanceId)))
		i += copy(dAtA[i:], m.InstanceId)
	}
	return i, nil
}

func (m *InstanceAttach) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceAttach) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Context.Size()))
	n9, err := m.Context.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.InstanceId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.InstanceId)))
		i += copy(dAtA[i:], m.InstanceId)
	}
	return i, nil
}

func (m *InstanceDetach) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceDetach) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Context.Size()))
	n10, err := m.Context.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.InstanceId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.InstanceId)))
		i += copy(dAtA[i:], m.InstanceId)
	}
	return i, nil
}

func (m *InstanceDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceDelete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Context.Size()))
	n11, err := m.Context.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if len(m.InstanceId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.InstanceId)))
		i += copy(dAtA[i:], m.InstanceId)
	}
	return i, nil
}

func encodeVarintEvent(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Event) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FailNetwork) Size() (n int) {
	var l int
	_ = l
	l = m.Context.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *FailProtocol) Size() (n int) {
	var l int
	_ = l
	l = m.Context.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *ServerAccess) Size() (n int) {
	var l int
	_ = l
	l = m.Context.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *FailRequest) Size() (n int) {
	var l int
	_ = l
	l = m.Context.Size()
	n += 1 + l + sovEvent(uint64(l))
	if m.Type != 0 {
		n += 1 + sovEvent(uint64(m.Type))
	}
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.InstanceArg != 0 {
		n += 1 + sovEvent(uint64(m.InstanceArg))
	}
	l = len(m.InstanceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *ProgramLoad) Size() (n int) {
	var l int
	_ = l
	l = m.Context.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.ProgramHash)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *ProgramCreate) Size() (n int) {
	var l int
	_ = l
	l = m.Context.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.ProgramHash)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *ProgramCheck) Size() (n int) {
	var l int
	_ = l
	l = m.Context.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceCreate) Size() (n int) {
	var l int
	_ = l
	l = m.Context.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.InstanceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceAttach) Size() (n int) {
	var l int
	_ = l
	l = m.Context.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.InstanceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceDetach) Size() (n int) {
	var l int
	_ = l
	l = m.Context.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.InstanceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceDelete) Size() (n int) {
	var l int
	_ = l
	l = m.Context.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.InstanceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func sovEvent(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEvent(x uint64) (n int) {
	return sovEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailProtocol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailProtocol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailProtocol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerAccess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerAccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerAccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (FailRequest_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceArg", wireType)
			}
			m.InstanceArg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceArg |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProgramLoad) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProgramLoad: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProgramLoad: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProgramCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProgramCreate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProgramCreate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProgramCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProgramCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProgramCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceCreate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceCreate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceAttach) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceAttach: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceAttach: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceDetach) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceDetach: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceDetach: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEvent
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEvent
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEvent(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEvent = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvent   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("server/event/event.proto", fileDescriptorEvent) }

var fileDescriptorEvent = []byte{
	// 605 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x95, 0x41, 0x8f, 0xd2, 0x40,
	0x14, 0xc7, 0x99, 0x52, 0x76, 0x97, 0x01, 0x77, 0x67, 0x27, 0xd9, 0x15, 0x49, 0x64, 0x77, 0x1b,
	0x0f, 0x9b, 0x98, 0x40, 0xb2, 0xde, 0x3c, 0x68, 0xba, 0x05, 0xa4, 0x09, 0xb4, 0xa4, 0xe0, 0x41,
	0x0f, 0x36, 0x43, 0x99, 0x50, 0xb2, 0x85, 0x62, 0x3b, 0xa0, 0x7b, 0xd4, 0xc4, 0xbb, 0x1f, 0xca,
	0x03, 0x47, 0xe3, 0xd9, 0x18, 0xc5, 0x2f, 0x62, 0xda, 0x4e, 0x37, 0xb4, 0x26, 0x9a, 0x26, 0xbb,
	0x17, 0x60, 0x7e, 0xbc, 0xf9, 0xbf, 0xd7, 0x79, 0xff, 0x79, 0x85, 0x15, 0x9f, 0x7a, 0x2b, 0xea,
	0x35, 0xe8, 0x8a, 0xce, 0x59, 0xf4, 0x59, 0x5f, 0x78, 0x2e, 0x73, 0x71, 0x21, 0x5c, 0x54, 0xab,
	0x3c, 0x60, 0x4c, 0x19, 0x99, 0x3a, 0xfc, 0x2b, 0x0a, 0x91, 0xbe, 0x03, 0x58, 0x68, 0x05, 0x51,
	0xd2, 0x37, 0x00, 0xc5, 0xe1, 0xf5, 0x82, 0xe2, 0x03, 0x58, 0x6a, 0x93, 0xa9, 0xa3, 0x51, 0xf6,
	0xce, 0xf5, 0xae, 0x50, 0x0e, 0x23, 0x58, 0x0e, 0x40, 0x3f, 0xd8, 0x60, 0xb9, 0x0e, 0x02, 0x01,
	0x19, 0x84, 0x9a, 0xb2, 0x65, 0x51, 0xdf, 0x47, 0x42, 0xbc, 0xc9, 0xa0, 0x6f, 0x97, 0xd4, 0x67,
	0x28, 0x1f, 0x80, 0xbe, 0xe7, 0x4e, 0x3c, 0x32, 0xeb, 0xba, 0x64, 0x8c, 0x44, 0x7c, 0x08, 0xef,
	0x71, 0xa0, 0x78, 0x94, 0x30, 0x8a, 0x0a, 0x81, 0x4c, 0x8c, 0x6c, 0x6a, 0x5d, 0xa1, 0x1d, 0x8c,
	0xe1, 0xbe, 0x3a, 0xf7, 0x19, 0x99, 0x5b, 0x94, 0x47, 0xed, 0x6e, 0x33, 0x99, 0x31, 0x62, 0xd9,
	0x68, 0x6f, 0x9b, 0x35, 0x69, 0xc8, 0x8a, 0x49, 0xe6, 0x50, 0x46, 0x11, 0x94, 0x9e, 0x25, 0x9e,
	0x05, 0x37, 0xe0, 0xae, 0xe5, 0xce, 0x19, 0x7d, 0xcf, 0x2a, 0xe0, 0x14, 0x9c, 0x97, 0x2e, 0x0e,
	0xea, 0xfc, 0x34, 0x94, 0x08, 0x5f, 0x8a, 0xeb, 0x1f, 0x27, 0x39, 0x23, 0x8e, 0x92, 0x9e, 0x27,
	0x1f, 0x3d, 0xbb, 0xc0, 0x27, 0x90, 0x3c, 0xaa, 0xcc, 0x0a, 0xb8, 0x0a, 0xf7, 0x16, 0x3c, 0x7d,
	0x45, 0x38, 0x05, 0xe7, 0x45, 0xe3, 0x66, 0x8d, 0x8f, 0xe1, 0xce, 0x8c, 0x32, 0xdb, 0x1d, 0x57,
	0xf2, 0xe1, 0x3f, 0x7c, 0x85, 0x11, 0xcc, 0x2f, 0x3d, 0xa7, 0x22, 0x86, 0x30, 0xf8, 0x29, 0x7d,
	0x11, 0x12, 0x0d, 0xca, 0x5e, 0xc6, 0x63, 0x28, 0xb2, 0xeb, 0x05, 0x0d, 0x4b, 0xd8, 0xbf, 0xb8,
	0x5f, 0x8f, 0x7c, 0xb6, 0x25, 0x59, 0x0f, 0xcc, 0x63, 0x84, 0x41, 0xf8, 0x21, 0x84, 0x8b, 0xa8,
	0xb1, 0xe6, 0x34, 0xae, 0xad, 0xc8, 0x89, 0x3a, 0xc6, 0x67, 0xb0, 0x3c, 0xe5, 0x9d, 0x32, 0x89,
	0x37, 0x09, 0xeb, 0x2c, 0x18, 0xa5, 0x98, 0xc9, 0xde, 0x04, 0x9f, 0xc0, 0x9b, 0x65, 0x20, 0x51,
	0x08, 0x25, 0x60, 0x8c, 0xd4, 0xb1, 0xc4, 0xb8, 0x5b, 0x03, 0x5b, 0xc9, 0xaf, 0xba, 0xba, 0xdc,
	0x34, 0x5b, 0x86, 0xa1, 0x1b, 0x28, 0x87, 0x8f, 0xe0, 0x61, 0xdf, 0xd0, 0x5f, 0x18, 0x72, 0xcf,
	0xd4, 0xf4, 0xa1, 0xd9, 0xd6, 0x5f, 0x6a, 0x4d, 0x04, 0xf0, 0x03, 0x78, 0x14, 0xe3, 0x8e, 0x3c,
	0xe8, 0x98, 0x3d, 0x75, 0xd0, 0x93, 0x87, 0x4a, 0x07, 0x09, 0xf8, 0x18, 0x62, 0x55, 0x1b, 0x0c,
	0x65, 0x4d, 0x69, 0x6d, 0x6d, 0x09, 0x4d, 0xac, 0xea, 0xa6, 0xa2, 0x6b, 0xed, 0xae, 0xaa, 0x0c,
	0x91, 0x28, 0x91, 0x84, 0xab, 0xb3, 0x9f, 0xe2, 0x19, 0x2c, 0xc7, 0x07, 0x63, 0x13, 0xdf, 0xe6,
	0x0d, 0x2d, 0x71, 0xd6, 0x21, 0xbe, 0x2d, 0x7d, 0x04, 0xa9, 0x8b, 0x72, 0x17, 0x59, 0xfe, 0xd3,
	0x21, 0xe9, 0x4d, 0xf2, 0x66, 0x66, 0x2f, 0x21, 0xa9, 0x2f, 0xa4, 0xf5, 0x3f, 0x80, 0xf4, 0x45,
	0xbf, 0xed, 0x14, 0x69, 0x07, 0xe5, 0xff, 0x72, 0xd0, 0x28, 0x3d, 0x57, 0xb2, 0x97, 0x90, 0xca,
	0x21, 0xfc, 0x2b, 0x47, 0x34, 0xa7, 0xee, 0x3a, 0x47, 0x30, 0xf7, 0x6e, 0x3f, 0xc7, 0xe5, 0xd3,
	0xf5, 0xaf, 0x5a, 0x6e, 0xbd, 0xa9, 0x81, 0xaf, 0x9b, 0x1a, 0xf8, 0xb9, 0xa9, 0x81, 0xcf, 0xbf,
	0x6b, 0xb9, 0xd7, 0x8f, 0x26, 0x53, 0x66, 0x2f, 0x47, 0x75, 0xcb, 0x9d, 0x35, 0x98, 0x4f, 0x56,
	0xae, 0x43, 0x1a, 0x13, 0xc2, 0x68, 0x63, 0xfb, 0x8d, 0x34, 0xda, 0x09, 0xc7, 0xd5, 0x93, 0x3f,
	0x01, 0x00, 0x00, 0xff, 0xff, 0xb1, 0x41, 0xc9, 0x93, 0xa8, 0x06, 0x00, 0x00,
}
